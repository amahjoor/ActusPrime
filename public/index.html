<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Actus Prime</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', sans-serif;
      background: rgba(10, 10, 15, 0.92);
      color: #e0e0e0;
      height: 100vh;
      overflow: hidden;
      backdrop-filter: blur(20px);
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 24px;
    }

    /* ── Header ─────────────────────────────────── */
    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      opacity: 0.7;
    }

    .header h1 {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #888;
    }

    .header .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4ade80;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    /* ── Expert Card ────────────────────────────── */
    .expert-card {
      display: none;
      align-items: center;
      gap: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      margin-bottom: 20px;
      animation: slideIn 0.4s ease-out;
    }

    .expert-card.visible {
      display: flex;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .expert-portrait {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      flex-shrink: 0;
      overflow: hidden;
    }

    .expert-portrait img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .expert-info {
      flex: 1;
    }

    .expert-name {
      font-size: 22px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 4px;
    }

    .expert-domain {
      font-size: 13px;
      color: #888;
      margin-bottom: 6px;
    }

    .expert-reasoning {
      font-size: 13px;
      color: #aaa;
      font-style: italic;
    }

    /* ── Status ──────────────────────────────────── */
    .status {
      display: none;
      padding: 12px 16px;
      background: rgba(74, 222, 128, 0.08);
      border: 1px solid rgba(74, 222, 128, 0.15);
      border-radius: 10px;
      margin-bottom: 16px;
      font-size: 13px;
      color: #4ade80;
      animation: slideIn 0.3s ease-out;
    }

    .status.visible {
      display: block;
    }

    .status.dispatching {
      background: rgba(250, 204, 21, 0.08);
      border-color: rgba(250, 204, 21, 0.15);
      color: #facc15;
    }

    .status.generating {
      background: rgba(168, 85, 247, 0.08);
      border-color: rgba(168, 85, 247, 0.15);
      color: #a855f7;
    }

    /* ── Output Feed ─────────────────────────────── */
    .output-feed {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
      margin-bottom: 16px;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.6;
      color: #ccc;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .output-feed::-webkit-scrollbar {
      width: 4px;
    }

    .output-feed::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
    }

    /* ── Input Area ──────────────────────────────── */
    .input-area {
      display: flex;
      gap: 10px;
    }

    .input-area input {
      flex: 1;
      padding: 14px 18px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: #fff;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
    }

    .input-area input:focus {
      border-color: rgba(255, 255, 255, 0.25);
    }

    .input-area input::placeholder {
      color: #555;
    }

    .btn {
      padding: 14px 24px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #fff;
      color: #000;
    }

    .btn-primary:hover {
      background: #e0e0e0;
    }

    .btn-primary:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .btn-mic {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.2);
      font-size: 18px;
      padding: 14px 18px;
    }

    .btn-mic:hover {
      background: rgba(239, 68, 68, 0.25);
    }

    .btn-mic.recording {
      background: rgba(239, 68, 68, 0.4);
      animation: pulse 1s ease-in-out infinite;
    }

    .btn-mute {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      opacity: 0.5;
      margin-left: auto;
      padding: 4px 8px;
      transition: opacity 0.2s;
    }

    .btn-mute:hover { opacity: 0.8; }
    .btn-mute.muted { opacity: 0.2; }
  </style>
</head>
<body>
  <div id="app">
    <div class="header">
      <div class="dot"></div>
      <h1>Actus Prime</h1>
      <button class="btn-mute" id="mute-btn" title="Toggle voice output">&#128266;</button>
    </div>

    <div id="expert-card" class="expert-card">
      <div class="expert-portrait" id="expert-portrait"></div>
      <div class="expert-info">
        <div class="expert-name" id="expert-name"></div>
        <div class="expert-domain" id="expert-domain"></div>
        <div class="expert-reasoning" id="expert-reasoning"></div>
      </div>
    </div>

    <div id="status" class="status"></div>

    <div class="output-feed" id="output-feed"></div>

    <div class="input-area">
      <button class="btn btn-mic" id="mic-btn" title="Hold to record">&#127908;</button>
      <input type="text" id="task-input" placeholder="Tell it what you need done..." autofocus />
      <button class="btn btn-primary" id="send-btn">Send</button>
    </div>
  </div>

  <script>
    const API = window.location.origin;

    const expertCard = document.getElementById('expert-card');
    const expertPortrait = document.getElementById('expert-portrait');
    const expertName = document.getElementById('expert-name');
    const expertDomain = document.getElementById('expert-domain');
    const expertReasoning = document.getElementById('expert-reasoning');
    const statusEl = document.getElementById('status');
    const outputFeed = document.getElementById('output-feed');
    const taskInput = document.getElementById('task-input');
    const sendBtn = document.getElementById('send-btn');
    const micBtn = document.getElementById('mic-btn');
    const muteBtn = document.getElementById('mute-btn');

    let isRunning = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let currentExpertName = '';
    let outputBuffer = ''; // accumulates text for TTS
    let isMuted = false;

    // ── TTS Voice Output (Edge Neural TTS via server, Web Speech API fallback) ──

    const synth = window.speechSynthesis;
    let voices = [];
    function loadVoices() { voices = synth.getVoices(); }
    loadVoices();
    synth.onvoiceschanged = loadVoices;

    // Audio queue for sequential playback
    let ttsQueue = [];
    let ttsPlaying = false;
    let ttsServerAvailable = true; // falls back to Web Speech if server TTS fails

    async function playNextInQueue() {
      if (ttsPlaying || ttsQueue.length === 0) return;
      ttsPlaying = true;

      const { text, expert } = ttsQueue.shift();

      if (ttsServerAvailable) {
        try {
          const res = await fetch(`${API}/api/tts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text, expert }),
          });

          if (!res.ok) throw new Error(`TTS ${res.status}`);

          const audioBlob = await res.blob();
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);

          audio.onended = () => {
            URL.revokeObjectURL(audioUrl);
            ttsPlaying = false;
            playNextInQueue();
          };
          audio.onerror = () => {
            URL.revokeObjectURL(audioUrl);
            ttsPlaying = false;
            playNextInQueue();
          };

          await audio.play();
          return;
        } catch (e) {
          console.warn('[tts] Server TTS failed, falling back to Web Speech:', e.message);
          ttsServerAvailable = false;
        }
      }

      // Fallback: Web Speech API
      const utterance = new SpeechSynthesisUtterance(text);
      const voice = voices.find(v => v.lang.startsWith('en')) || voices[0];
      if (voice) utterance.voice = voice;
      utterance.rate = 1.05;
      utterance.onend = () => { ttsPlaying = false; playNextInQueue(); };
      utterance.onerror = () => { ttsPlaying = false; playNextInQueue(); };
      synth.speak(utterance);
    }

    function speakText(text) {
      if (!text.trim() || isMuted) return;
      ttsQueue.push({ text, expert: currentExpertName });
      playNextInQueue();
    }

    function cancelAllSpeech() {
      ttsQueue = [];
      ttsPlaying = false;
      synth.cancel();
      // Stop any playing HTML5 audio elements
      document.querySelectorAll('audio').forEach(a => { a.pause(); a.remove(); });
    }

    // Flush accumulated output buffer as speech at sentence boundaries
    function flushSpeechBuffer() {
      let match;
      while ((match = outputBuffer.match(/^([\s\S]*?[.!?:]["'\s])/))) {
        const sentence = match[1].trim();
        outputBuffer = outputBuffer.slice(match[1].length);
        if (sentence.length > 5) speakText(sentence);
      }
    }

    // ── Send task ────────────────────────────────

    function setStatus(msg, type = '') {
      statusEl.textContent = msg;
      statusEl.className = 'status visible ' + type;
    }

    function clearStatus() {
      statusEl.className = 'status';
    }

    function showExpert(data) {
      expertName.textContent = data.expert;
      expertDomain.textContent = data.domain;
      expertReasoning.textContent = data.reasoning;

      // Use first letter as fallback portrait
      expertPortrait.innerHTML = '';
      expertPortrait.textContent = data.expert.charAt(0);
      expertPortrait.style.fontSize = '32px';

      expertCard.className = 'expert-card visible';
    }

    async function sendTask(task) {
      if (!task || isRunning) return;
      isRunning = true;
      sendBtn.disabled = true;
      outputFeed.textContent = '';
      outputBuffer = '';
      cancelAllSpeech();
      expertCard.className = 'expert-card';

      setStatus('Analyzing task...', 'dispatching');

      try {
        const res = await fetch(`${API}/api/pipeline`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ task }),
        });

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop();

          for (const line of lines) {
            if (!line.startsWith('data: ')) continue;
            try {
              const data = JSON.parse(line.slice(6));

              if (data.type === 'dispatch') {
                showExpert(data);
                currentExpertName = data.expert;
                setStatus(`${data.expert} is taking over...`);
              } else if (data.type === 'status') {
                const cls = data.stage === 'dispatch' ? 'dispatching' :
                            data.stage === 'factory' ? 'generating' : '';
                setStatus(data.message, cls);
              } else if (data.type === 'output') {
                outputFeed.textContent += data.text;
                outputFeed.scrollTop = outputFeed.scrollHeight;
                // Buffer text for TTS and speak at sentence boundaries
                outputBuffer += data.text;
                flushSpeechBuffer();
              } else if (data.type === 'done') {
                clearStatus();
                // Speak any remaining buffered text
                if (outputBuffer.trim()) {
                  speakText(outputBuffer.trim());
                  outputBuffer = '';
                }
              } else if (data.type === 'error') {
                setStatus('Error: ' + data.message, '');
              }
            } catch {}
          }
        }
      } catch (e) {
        setStatus('Connection error: ' + e.message, '');
      }

      isRunning = false;
      sendBtn.disabled = false;
    }

    // ── Event listeners ──────────────────────────

    muteBtn.addEventListener('click', () => {
      isMuted = !isMuted;
      muteBtn.textContent = isMuted ? '\u{1F507}' : '\u{1F50A}';
      muteBtn.classList.toggle('muted', isMuted);
      if (isMuted) cancelAllSpeech();
    });

    sendBtn.addEventListener('click', () => {
      const task = taskInput.value.trim();
      if (task) {
        taskInput.value = '';
        sendTask(task);
      }
    });

    taskInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendBtn.click();
      }
    });

    // ── Mic recording ────────────────────────────

    micBtn.addEventListener('mousedown', startRecording);
    micBtn.addEventListener('mouseup', stopRecording);
    micBtn.addEventListener('mouseleave', stopRecording);
    micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); });
    micBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); });

    async function startRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
        mediaRecorder.onstop = async () => {
          stream.getTracks().forEach(t => t.stop());
          const blob = new Blob(audioChunks, { type: 'audio/webm' });
          await transcribeAudio(blob);
        };

        mediaRecorder.start();
        micBtn.classList.add('recording');
      } catch (e) {
        console.error('Mic error:', e);
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        micBtn.classList.remove('recording');
      }
    }

    async function transcribeAudio(blob) {
      setStatus('Transcribing...', 'dispatching');
      try {
        const form = new FormData();
        form.append('audio', blob, 'recording.webm');

        const res = await fetch(`${API}/api/transcribe`, {
          method: 'POST',
          body: form,
        });

        const data = await res.json();
        if (data.text) {
          taskInput.value = data.text;
          clearStatus();
          // Auto-send after transcription
          sendTask(data.text);
        } else {
          setStatus('Could not transcribe audio', '');
        }
      } catch (e) {
        setStatus('Transcription error: ' + e.message, '');
      }
    }
  </script>
</body>
</html>
